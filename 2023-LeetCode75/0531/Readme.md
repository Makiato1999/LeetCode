## 392-IsSubsequence
#### Dynamic Programming
我们以输入 s = "abc"、t = "ahbgdc" 为例，构建一个 4×7 的矩阵来记录子问题的最优解。其中第一行和第一列都初始化为 0，表示当任意一个字符串为空串时，它和任意一个非空字符串的最长公共子序列长度都为 0。
```
    int m = s.length(), n = t.length();
    // 创建一个记录子问题最优解的二维数组
    int[][] dp = new int[m + 1][n + 1];
    // 初始化矩阵第一行和第一列
    for (int i = 0; i <= m; i++) {
        dp[i][0] = 0;
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = 0;
    }
```
| dp[i][j] | 0     | a     | h     | b     | g     | d     | c     |
| -------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| 0        | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| a        | 0     |      |      |      |      |      |      |
| b        | 0     |      |      |      |      |      |      |
| c        | 0     |      |      |      |      |      |      |

之后，两个字符串互相比，在dp中记录，逻辑如下
- 如果 s[i-1] = t[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1；
- 如果 s[i-1] ≠ t[j-1]，则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])

如果相等，就dp中+1，如果不等，就在左边和上边中找一个最大的值填上
```
    // 计算矩阵中其他位置的最优解
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s.charAt(i - 1) == t.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    // 判断 s 是否为 t 的子序列
    return dp[m][n] == m;
```
最终形成如下结果，判断出dp中最长的值3，满足条件
| dp[i][j] | 0     | a     | h     | b     | g     | d     | c     |
| -------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| 0        | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| a        | 0     | 1     | 1     | 1     | 1     | 1     | 1     |
| b        | 0     | 1     | 1     | 2     | 2     | 2     | 2     |
| c        | 0     | 1     | 1     | 2     | 2     | 2     | 3     |

